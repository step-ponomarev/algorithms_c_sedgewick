#include "../../src/collections/tree.h"
#include "../../src/lib/rand_utils.c"
#include <assert.h>
#include <stddef.h>
#include <stdio.h>

#define AMOUNT 10000

static size_t ptr = 0;
static int visited[AMOUNT];

static void visit(const void *val) {
  const int d = *((int *)val);
  visited[ptr++] = d;
}

static void traversal(const Tree *tree, const Order order) {
  ptr = 0;
  tree_traversal(tree, &visit, order);
}

int comare_int(const void *a, const void *b) {
  return *((int *)a) - *((int *)b);
}

void test_tree_adding() {
  Tree *tree = tree_create(sizeof(int), &comare_int);
  for (int i = 0; i < AMOUNT; i++) {
    tree_add(tree, &i);
  }

  assert(tree_size(tree) == AMOUNT);
  assert(!tree_is_empty(tree));

  for (int i = 0; i < AMOUNT; i++) {
    assert(tree_contains(tree, &i));
  }

  tree_destroy(tree);
}

void test_tree_duplicate_adding() {
  Tree *tree = tree_create(sizeof(int), &comare_int);
  int added_value = 123;
  for (int i = 0; i < AMOUNT; i++) {
    tree_add(tree, &added_value);
  }

  assert(tree_size(tree) == 1);
  assert(!tree_is_empty(tree));

  tree_destroy(tree);
}

void test_tree_removing() {
  Tree *tree = tree_create(sizeof(int), &comare_int);
  for (int i = 0; i < AMOUNT; i++) {
    tree_add(tree, &i);
  }

  for (int i = AMOUNT - 1; i >= 0; i--) {
    tree_remove(tree, &i);
  }

  assert(tree_size(tree) == 0);
  assert(tree_is_empty(tree));

  tree_destroy(tree);
}

void test_in_order_visitin() {
  Tree *tree = tree_create(sizeof(int), &comare_int);
  for (int i = 0; i < AMOUNT; i++) {
    tree_add(tree, &i);
  }

  traversal(tree, LNR);
  for (int i = 0; i < AMOUNT; i++) {
    assert(visited[i] == i);
  }

  assert(tree_size(tree) == AMOUNT);
  assert(!tree_is_empty(tree));

  tree_destroy(tree);
}

void test_reverse_order_visitin() {
  Tree *tree = tree_create(sizeof(int), &comare_int);
  for (int i = 0; i < AMOUNT; i++) {
    tree_add(tree, &i);
  }

  traversal(tree, RNL);
  for (int i = 0; i < AMOUNT; i++) {
    assert(visited[i] == (AMOUNT - 1) - i);
  }

  assert(tree_size(tree) == AMOUNT);
  assert(!tree_is_empty(tree));

  tree_destroy(tree);
}

void test_in_order_visitin_rand() {
  Tree *tree = tree_create(sizeof(int), &comare_int);

  for (int i = 0; i < AMOUNT; i++) {
    const int val = random_int(-121, 120);
    tree_add(tree, &val);
  }

  traversal(tree, LNR);
  size_t size = tree_size(tree);
  for (size_t i = 1; i < size; i++) {
    assert(visited[i - 1] < visited[i]);
  }

  assert(!tree_is_empty(tree));

  tree_destroy(tree);
}

void test_reverse_order_visitin_rand() {
  Tree *tree = tree_create(sizeof(int), &comare_int);

  for (int i = 0; i < AMOUNT; i++) {
    const int val = random_int(0, 19999);
    tree_add(tree, &val);
  }

  traversal(tree, RNL);
  size_t size = tree_size(tree);
  for (size_t i = 1; i < size; i++) {
    assert(visited[i - 1] > visited[i]);
  }

  assert(!tree_is_empty(tree));

  tree_destroy(tree);
}

void test_min() {
  Tree *tree = tree_create(sizeof(int), &comare_int);

  for (int i = 0; i < AMOUNT; i++) {
    tree_add(tree, &i);
  }

  int *min = (int *)tree_min(tree);
  assert(*min == 0);

  free(min);
  const int new_min = -1211;
  tree_add(tree, &new_min);

  min = (int *)tree_min(tree);
  assert(*min == new_min);
  free(min);

  tree_destroy(tree);
}

void test_max() {
  Tree *tree = tree_create(sizeof(int), &comare_int);

  for (int i = 0; i < AMOUNT; i++) {
    tree_add(tree, &i);
  }

  int *max = (int *)tree_max(tree);
  assert(*max == AMOUNT - 1);

  free(max);
  const int new_max = AMOUNT + 211;
  tree_add(tree, &new_max);

  max = (int *)tree_max(tree);
  assert(*max == new_max);
  free(max);

  tree_destroy(tree);
}

int main() {
  // test_tree_adding();
  // test_tree_removing();
  // test_in_order_visitin();
  // test_reverse_order_visitin();
  test_in_order_visitin_rand();
  // test_reverse_order_visitin_rand();
  // test_tree_duplicate_adding();
  // test_min();
  // test_max();

  printf("Tests are passed\n");
}
